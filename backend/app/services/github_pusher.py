from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass
from pathlib import Path

import httpx

log = logging.getLogger("mcp.github")

GIT_ENV = {
    "GIT_AUTHOR_NAME": "MCP Factory",
    "GIT_AUTHOR_EMAIL": "noreply@mcp-factory.dev",
    "GIT_COMMITTER_NAME": "MCP Factory",
    "GIT_COMMITTER_EMAIL": "noreply@mcp-factory.dev",
}


@dataclass
class GitHubPushResult:
    success: bool
    repo_url: str | None = None
    error: str | None = None


class GitHubPusher:
    GITHUB_API = "https://api.github.com"

    async def push(
        self,
        project_dir: str,
        token: str,
        repo_name: str,
        private: bool = True,
        description: str = "",
    ) -> GitHubPushResult:
        """Create a GitHub repo and push project code to it."""
        try:
            owner = await self._get_username(token)
            log.info("GitHub user: %s", owner)

            repo_url = await self._create_repo(token, repo_name, private, description)
            log.info("Created repo: %s", repo_url)

            await self._git_push(project_dir, token, owner, repo_name)
            log.info("Pushed code to %s", repo_url)

            return GitHubPushResult(success=True, repo_url=repo_url)

        except Exception as e:
            log.error("GitHub push failed: %s", e)
            return GitHubPushResult(success=False, error=str(e))

    async def _get_username(self, token: str) -> str:
        async with httpx.AsyncClient() as client:
            resp = await client.get(
                f"{self.GITHUB_API}/user",
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github+json",
                },
                timeout=10,
            )
            if resp.status_code == 401:
                raise ValueError("Invalid GitHub token. Check your PAT and try again.")
            resp.raise_for_status()
            return resp.json()["login"]

    async def _create_repo(
        self, token: str, name: str, private: bool, description: str
    ) -> str:
        async with httpx.AsyncClient() as client:
            resp = await client.post(
                f"{self.GITHUB_API}/user/repos",
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github+json",
                },
                json={
                    "name": name,
                    "private": private,
                    "description": description,
                    "auto_init": False,
                },
                timeout=15,
            )
            if resp.status_code == 422:
                errors = resp.json().get("errors", [])
                msg = (
                    errors[0].get("message", "Repository name already exists")
                    if errors
                    else "Repository creation failed (name conflict?)"
                )
                raise ValueError(f"GitHub repo creation failed: {msg}")
            resp.raise_for_status()
            return resp.json()["html_url"]

    async def _git_push(
        self, project_dir: str, token: str, owner: str, repo_name: str
    ) -> None:
        import os

        remote_url = f"https://{token}@github.com/{owner}/{repo_name}.git"
        env = {**os.environ, **GIT_ENV}

        commands = [
            ["git", "init"],
            ["git", "add", "."],
            ["git", "commit", "-m", "Initial commit - generated by MCP Factory"],
            ["git", "branch", "-M", "main"],
            ["git", "remote", "add", "origin", remote_url],
            ["git", "push", "-u", "origin", "main"],
        ]

        for cmd in commands:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=project_dir,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=env,
            )
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=30)
            if proc.returncode != 0:
                error_text = stderr.decode("utf-8", errors="replace").strip()
                error_text = error_text.replace(token, "***")
                safe_cmd = " ".join(cmd[:2])
                raise RuntimeError(f"Git command failed ({safe_cmd}): {error_text[:300]}")


github_pusher = GitHubPusher()
